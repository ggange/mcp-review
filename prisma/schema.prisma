generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // In Prisma 7+, connection URLs are configured in prisma.config.ts for migrations
  // and via adapter in src/lib/db.ts for runtime connections
}

// NextAuth.js models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String       @id @default(cuid())
  name          String?
  email         String?      @unique
  emailVerified DateTime?
  image         String?
  role          String       @default("user") // "user" | "admin"
  createdAt     DateTime     @default(now())
  accounts      Account[]
  sessions      Session[]
  ratings       Rating[]
  reviewVotes   ReviewVote[]
  reviewFlags   ReviewFlag[]
  servers       Server[]     // Servers created by this user
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// MCP Review models
model Server {
  id                 String   @id
  name               String
  organization       String?  // Optional organization
  description        String?  @db.Text
  version            String?
  repositoryUrl      String?
  packages           Json?
  remotes            Json?

  // Aggregated ratings
  avgTrustworthiness Float    @default(0)
  avgUsefulness      Float    @default(0)
  totalRatings       Int      @default(0)
  
  // Computed fields for efficient sorting
  combinedScore      Float    @default(0) // (avgTrustworthiness + avgUsefulness) / 2
  recentRatingsCount Int      @default(0) // Ratings in last 30 days (updated periodically)

  category           String?  // "database", "search", "code", "web", "ai", "data", "tools", "other"
  createdAt          DateTime @default(now())
  syncedAt           DateTime @default(now())
  source             String   @default("registry") // "registry" | "user" | "official"
  iconUrl            String?  // URL to custom icon stored in R2
  tools              Json?    // Array of {name: string, description: string} objects
  usageTips          String?  @db.Text // Optional usage tips and suggestions
  hasManyTools       Boolean  @default(false) // Flag indicating server has 5+ tools
  completeToolsUrl   String?  // URL to complete list of tools (when hasManyTools is true)
  userId             String?  // User who created this server (for user-uploaded servers)
  authorUsername     String?  // GitHub username of the author (for display)

  ratings            Rating[]
  user               User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([name])
  @@index([organization])
  @@index([source])
  @@index([createdAt])
  @@index([combinedScore]) // For top-rated sort
  @@index([recentRatingsCount]) // For trending sort
  @@index([source, category]) // For filtered queries
}

model Rating {
  id              String       @id @default(cuid())
  trustworthiness Int          // 1-5
  usefulness      Int          // 1-5
  text            String?      @db.Text // Optional review text
  status          String       @default("approved") // "approved", "flagged", "removed"
  helpfulCount    Int          @default(0)
  notHelpfulCount Int          @default(0)
  flagCount       Int          @default(0) // Number of unique flags
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  server      Server       @relation(fields: [serverId], references: [id], onDelete: Cascade)
  serverId    String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  reviewVotes ReviewVote[]
  reviewFlags ReviewFlag[]

  @@unique([serverId, userId]) // One rating per user per server
  @@index([status, serverId]) // For filtering approved reviews by server
  @@index([createdAt]) // For trending sort by recent ratings
  @@index([serverId]) // For server-specific rating queries
}

model ReviewVote {
  id        String   @id @default(cuid())
  ratingId  String
  userId    String
  helpful   Boolean  // true for helpful, false for not helpful
  createdAt DateTime @default(now())

  rating Rating @relation(fields: [ratingId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([ratingId, userId]) // One vote per user per review
  @@index([ratingId, helpful]) // For counting helpful/not helpful votes efficiently
}

model ReviewFlag {
  id        String   @id @default(cuid())
  ratingId  String
  userId    String
  reason    String?  @db.Text // Optional reason for flagging
  createdAt DateTime @default(now())

  rating Rating @relation(fields: [ratingId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([ratingId, userId]) // One flag per user per review
  @@index([ratingId])
}
